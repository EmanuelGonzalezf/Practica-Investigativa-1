mod ITERATED-PRISONERS-DILEMMA is
  --- Importaciones necesarias y recomendadas
  protecting NAT .   --- números naturales
  protecting BOOL .  --- valores booleanos si se quieren usar en condiciones

  --- Acciones posibles
  sorts Action .
  ops C T : -> Action [ctor] .   --- C = Cooperar, T = Traicionar

  --- Jugadores
  sorts Player .
  ops P1 P2 : -> Player [ctor] .

  --- Estrategias
  sorts Strategy .
  ops SiempreC SiempreT TitForTat : -> Strategy [ctor] .

  --- Estado del juego: 
  --- <Ronda, AccionP1, AccionP2, PagoAcumP1, PagoAcumP2, EstrategiaP1, EstrategiaP2>
  sorts State .
  op <_,_,_,_,_,_,_> : Nat Action Action Nat Nat Strategy Strategy -> State [ctor] .

  --- Función de pago clásico del dilema del prisionero
  op payoff : Action Action Player -> Nat .

  eq payoff(C, C, P1) = 3 .

  eq payoff(C, C, P2) = 3 .

  eq payoff(C, T, P1) = 0 .

  eq payoff(C, T, P2) = 5 .

  eq payoff(T, C, P1) = 5 .

  eq payoff(T, C, P2) = 0 .

  eq payoff(T, T, P1) = 1 .

  eq payoff(T, T, P2) = 1 .

  --- Función para decidir la acción según la estrategia
  --- Nota: en este modelo, TitForTat depende solo de la acción pasada del rival
  op choose : Strategy Action -> Action .

  --- SiempreC siempre coopera
  eq choose(SiempreC, C) = C .
  eq choose(SiempreC, T) = C .

  --- SiempreT siempre traiciona
  eq choose(SiempreT, C) = T .
  eq choose(SiempreT, T) = T .

  --- TitForTat copia la última acción del oponente
  eq choose(TitForTat, C) = C .
  eq choose(TitForTat, T) = T .

  --- Regla de evolución: jugar una ronda más
  var N : Nat .
  vars A1 A2 : Action .
  vars P1s P2s : Nat .
  vars S1 S2 : Strategy .
  rl [step] :
    < N A1 A2 P1s P2s S1 S2 >
    =>
    < N + 1
      choose(S1, A2)        
      choose(S2, A1)        
      P1s + payoff(choose(S1, A2), choose(S2, A1), P1)
      P2s + payoff(choose(S1, A2), choose(S2, A1), P2)
      S1 S2 > .
endm
